from queue import Queue
from threading import Timer as _Timer
import sys
import dataclasses
import logging.config
import json

sys.path.append("lib/fleet-protocol/protobuf/compiled/python")

from external_server.checkers.checker import Checker as _Checker
from external_server.models.structures import (
    Counter as _Counter,
    HandledCommand as _HandledCommand,
    TimeoutType as _TimeoutType
)


logger = logging.getLogger(__name__)
with open("./config/logging.json", "r") as f:
    logging.config.dictConfig(json.load(f))


@dataclasses.dataclass(frozen=True)
class QueuedCommand:
    """This class binds Command message with its counter value, the flag denoting if the
    command was returned by get_command API function or generated by the server, and a timer.
    """

    command: _HandledCommand
    timer: _Timer

    def stop_timer(self) -> None:
        """Stop the timer for this command."""
        self.timer.cancel()
        self.timer.join()


class CommandQueue:
    """It stores instances of `QueuedCommand` and provides methods for adding and removing
    them from the queue.
    """

    def __init__(self) -> None:
        self._queue: Queue[QueuedCommand] = Queue()

    @property
    def oldest_counter(self) -> _Counter | None:
        """Get the counter of the oldest command in the queue."""
        if self._queue.empty():
            return None
        else:
            cmd: QueuedCommand = self._queue.queue[0]
            return cmd.command.counter

    def clear(self) -> None:
        """Remove all commands from queue and stop their timers."""
        while not self._queue.empty():
            cmd = self._queue.get()
            cmd.stop_timer()

    def empty(self) -> bool:
        """Check if the queue is empty."""
        return self._queue.empty()

    def get(self) -> _HandledCommand:
        """Get the oldest command (instance of `QueuedCommand`) from the queue and stop its timer."""
        cmd: QueuedCommand = self._queue.get()
        cmd.stop_timer()
        return cmd.command

    def put(self, command: _HandledCommand, timer: _Timer) -> None:
        """Put the command (instance of `HandledCommand`) into the queue."""
        self._queue.put(QueuedCommand(command, timer))


class CommandChecker(_Checker):
    """Checks for order of received Command responses and checks if duration between
    sending Command and receiving Command reponses do not exceeds timeout given in
    constructor.

    Is also External Server's memory of commands, which didn't have
    received Command response yet.
    """

    def __init__(self, timeout: float) -> None:
        super().__init__(_TimeoutType.COMMAND_TIMEOUT, timeout=timeout)
        self._commands = CommandQueue()
        self._missed_counter_vals: list[_Counter] = []
        self._counter = 0

    @property
    def n_of_expected_reponses(self) -> int:
        return self._commands._queue.qsize()

    def pop_commands(self, counter: _Counter) -> list[_HandledCommand]:
        """ Returns list of Command messages acknowledged with Command responses in correct order.
        With every command the returned_from_api flag is also returned.

        Can return empty list if received Command responses in wrong order.

        Stops the timer for acknowledged commands. Should be called when Command
        response from Module gateway is received.

        Parameters
        ----------
        counter : int
            number of command, which was acknowledged by received commandResponse
        """
        if self._commands.oldest_counter != counter:
            self._missed_counter_vals.append(counter)
            self._logger.warning(
                f"Cannot return command with counter={counter}, "
                f"because it is not the oldest command (counter={self._commands.oldest_counter})."
            )
            return []
        else:
            popped = [self._commands.get()]
            self._logger.info(f"Received Command response was acknowledged, counter={counter}")
            while self._missed_counter_vals:
                counter = self._commands.oldest_counter
                if (counter is not None) and (counter in self._missed_counter_vals):
                    command = self._commands.get()
                    popped.append(command)
                    self._missed_counter_vals.remove(counter)
                    self._logger.info(f"Older Command response acknowledged, counter={counter}")
                else:
                    break
            return popped

    def add(self, command: _HandledCommand) -> _HandledCommand:
        """Adds command to checker

        Adds given command to this checker. Starts timeout for Command response. Set
        the returned_from_api to True if command was returned by get_command API
        function. Should be called when command is sent to Module gateway.
        """
        command.update_counter_value(self._counter)
        self._commands.put(command, self._get_started_timer())
        logger.debug(f"Command added to checker, counter={self._counter}")
        self._counter += 1
        return command

    def reset(self) -> None:
        self._commands.clear()
        self._missed_counter_vals.clear()
        self._timeout_event.clear()

    def _get_started_timer(self) -> _Timer:
        """Get the timer object for the oldest command in the queue and start it."""
        timer = _Timer(self._timeout, self._create_timeout_event)
        timer.start()
        return timer