from queue import Queue
from threading import Timer as _Timer
import sys
import dataclasses
import logging

sys.path.append("lib/fleet-protocol/protobuf/compiled/python")

from external_server.checkers.checker import Checker as _Checker
from external_server.models.structures import (
    Counter as _Counter,
    HandledCommand as _HandledCommand,
    TimeoutType as _TimeoutType
)


logger = logging.getLogger(__name__)


@dataclasses.dataclass(frozen=True)
class QueuedCommand:
    """This class binds Command message with its counter value, the flag denoting if the
    command was returned by get_command API function or generated by the server, and a timer.
    """

    command: _HandledCommand
    timer: _Timer

    def stop_timer(self) -> None:
        """Stop the timer for this command."""
        self.timer.cancel()
        self.timer.join()


class CommandQueue:
    """It stores instances of `QueuedCommand` and provides methods for adding and removing
    them from the queue.
    """

    def __init__(self) -> None:
        self._queue: Queue[QueuedCommand] = Queue()

    @property
    def oldest_command_counter(self) -> _Counter | None:
        """Get the counter of the oldest command in the queue.

        Returns None if the queue is empty.
        """
        if self._queue.empty():
            return None
        else:
            cmd: QueuedCommand = self._queue.queue[0]
            return cmd.command.counter

    def clear(self) -> None:
        """Remove all commands from queue and stop their timers."""
        while not self._queue.empty():
            cmd = self._queue.get()
            cmd.stop_timer()

    def empty(self) -> bool:
        """Check if the queue is empty."""
        return self._queue.empty()

    def get(self) -> _HandledCommand:
        """Get the oldest command (instance of `QueuedCommand`) from the queue and stop its timer."""
        cmd: QueuedCommand = self._queue.get()
        cmd.stop_timer()
        logger.debug(f"Command retrieved from the command checker queue, number of remaining stored commands: {self._queue.qsize()}")
        return cmd.command

    def put(self, command: _HandledCommand, timer: _Timer) -> None:
        """Put the command (instance of `HandledCommand`) into the queue."""
        self._queue.put(QueuedCommand(command, timer))
        logger.debug(f"Command added to the command checker queue. Number of stored commands: {self._queue.qsize()}")


class CommandChecker(_Checker):
    """Checks for order of received Command responses and checks if duration between
    sending Command and receiving Command reponses do not exceeds timeout given in
    constructor.

    Is also External Server's memory of commands, which didn't have
    received Command response yet.
    """

    def __init__(self, timeout: float) -> None:
        super().__init__(_TimeoutType.COMMAND_RESPONSE_TIMEOUT, timeout=timeout)
        self._commands = CommandQueue()
        self._missed_counter_vals: list[_Counter] = []
        self._counter = 0

    @property
    def n_of_expected_reponses(self) -> int:
        return self._commands._queue.qsize()

    def pop_commands(self, response_counter: _Counter) -> list[_HandledCommand]:
        """ Returns list of Command messages acknowledged with Command responses in correct order.
        With every command the returned_from_api flag is also returned.

        Can return empty list if received Command responses in wrong order.

        Stops the timer for acknowledged commands. Should be called when Command
        response from Module gateway is received.

        Parameters
        ----------
        counter : int
            number of command, which was acknowledged by received commandResponse
        """
        oldest_counter = self._commands.oldest_command_counter
        if oldest_counter != response_counter:
            if oldest_counter is None:
                logger.warning(
                    "No commands in the queue awaiting a response. "
                    f"Ignoring the recevied response (counter={response_counter})."
                )
            else:
                self._missed_counter_vals.append(response_counter)
                logger.warning(
                    f"Cannot pop command with counter={response_counter} "
                    f"because it is not the oldest command (counter={self._commands.oldest_command_counter})."
                )
            return []
        else:
            cmds = [self._commands.get()]
            logger.info(f"Command response was acknowledged, counter={response_counter}")
            next_counter = self._commands.oldest_command_counter
            while next_counter in self._missed_counter_vals:
                cmds.append(self._commands.get())
                self._missed_counter_vals.remove(next_counter)
                next_counter = self._commands.oldest_command_counter
                logger.info(f"Older command response acknowledged, counter={next_counter}")
            logger.debug(f"Popping commands with counter values: {', '.join(str(cmd.counter) for cmd in cmds)}")
            return cmds

    def add(self, command: _HandledCommand) -> _HandledCommand:
        """Adds command to checker

        Adds given command to this checker. Starts timeout for Command response. Set
        the returned_from_api to True if command was returned by get_command API
        function. Should be called when command is sent to Module gateway.
        """
        command.update_counter_value(self._counter)
        self._commands.put(command, self._get_started_timer())
        logger.debug(f"Command added to checker, counter={self._counter}")
        self._counter += 1
        return command

    def reset(self) -> None:
        self._commands.clear()
        self._missed_counter_vals.clear()
        self._timeout_event.clear()

    def _get_started_timer(self) -> _Timer:
        """Get the timer object for the oldest command in the queue and start it."""
        timer = _Timer(self._timeout, self.set_timeout)
        timer.start()
        return timer